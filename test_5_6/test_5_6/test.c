#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//位段（不同系统下分配不同）
//位段的内存分配
//1.位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 
//2.位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。 
//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
//位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2.位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。 
//3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。 
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位 还是利用，这是不确定的
//struct A
//{
//	int a : 2;//32-2个比特位
//	int b : 5;//32-5个比特位
//	int c : 10;//32-10个比特位
//	//a,b,c共用一个整形的中32个比特位中的17个比特位
//	int d : 30;//32-30个比特位
//	//由于d要占用30个比特位，而第一个整形已经占用了17个，剩余的不足与30个比特位，重新开辟一个整形给d用
//};//A就是一个位段类型
//int main()
//{
//	printf("%d\n", sizeof(struct A));
//	return 0;
//}
////跟结构体（浪费空间，提高效率）相比，位段（节省空间，效率降低）可以达到同样的效果，但是可以很好的节省空间，但是有跨平台问题的存在
//
////枚举——把可能的取值列举
////性别、男、女、保密；十二个月份；颜色等等
////1. 增加代码的可读性和可维护性 
////2. 和#deﬁne定义的标识符比较枚举有类型检查，更加严谨。 
////3. 防止了命名污染（封装） 
////4. 便于调试 
////5. 使用方便，一次可以定义多个常
//enum Day//星期
//{
//	Mon,//0
//	Tues,//1
//	Wed,//2
//	Thur,//3
//	Fir,//4
//	Sat,//5
//	Sun//6
//};
//enum Sex//性别
//{
//	MALE,//0
//	FEMALE,/1
//	SECRET//2
//};
//enum Color//颜色
//{
//	RED,//0
//	GREEN,//1
//	BLUE//2
//};
////以上{}里的内容是枚举型的可能取值，也叫枚举常量
////这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初始值
//enum Color
//{
//	RED=1,
//	GREEN=2,
//	BLUE=4
//};
//enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异
////clr = 5;//错误的
//enum Color
//{
//	RED = 1,
//	GREEN = 5,
//	BLUE //此时他的值是6
//};
//枚举的使用（简单的计算器）
//void menu()
//{
//	printf("********************************\n");
//	printf("***     1.add      2.sub     ***\n");
//	printf("***     3.mul      4.div     ***\n");
//	printf("***     0.exit               ***\n");
//	printf("********************************\n");
//}
//enum Option
//{
//	exit,
//	add,
//	sub,
//	mul,
//	div
//};
//int main()
//{
//	int input = 0;
//	do
//	{
//		menu();
//		printf("请输入选项:>");
//		scanf("%d", &input);
//		switch (input)
//		{
//		//算法此处不实现
//		case add:
//			break;
//		case sub:
//			break;
//		case mul:
//			break;
//		case div:
//			break;
//		case exit:
//			printf("退出！\n");
//			break;
//		default:
//			printf("输入错误，请重新输入！\n");
//			break;
//		}
//	} while (input);
//	return 0;
//}

//联合（共用体）
//联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，
//特征是这些成员公用同一块空间（所以 联合也叫共用体）
//union Un
//{
//	char c;
//	int i;
//};
//int main()
//{
//	union Un un;
//	printf("%d\n", sizeof(un));
//	return 0;
//}
//联合体的特点
//联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有 能力保存最大的那个成员）。
//union Un
//{
//	char c;
//	int i;
//};
//int main()
//{
//	union Un un;
//	//printf("%p\n", &(un.i));
//	//printf("%p\n", &(un.c));
//	un.i = 0x11223344;
//	un.c = 0x55;
//	printf("%x\n", un.i);
//	printf("%x\n", un.c);
//	return 0;
//}
//判断当前计算机的大小端存储（使用联合体）
//int main()
//{
//	union 
//	{
//		int i;
//		char j;
//	}u;//匿名使用（只使用一次）
//	u.i = 1;
//	//00 00 00 01（十六进制表示）——i（int）
//	//01 00 00 00（小端）
//	//00 00 00 01（大端）
//	//利用char只取出一个字节来判断
//	//利用联合体共用同一块空间来判断
//	if (u.j == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}

//联合的大小至少是最大成员的大小。
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。
//union Un1 
//{ 
//	char c[5]; 
//	int i; 
//}; 
//union Un2 
//{
//	short c[7];
//	int i; 
//}; 
//int main()
//{
//	printf("%d\n", sizeof(union Un1));//8
//	printf("%d\n", sizeof(union Un2));//16
//	return 0;
//}

